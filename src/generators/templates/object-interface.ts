export interface ObjectInterfaceTemplateField {
  readonly name: string;
  readonly type: string;
  readonly optional: boolean;
  readonly jsDoc: readonly string[];
}

export interface ObjectInterfaceTemplateOptions {
  readonly objectName: string;
  readonly interfaceName: string;
  readonly description?: string;
  readonly sourcePath?: string;
  readonly traits: readonly string[];
  readonly generatedAt?: Date;
  readonly fields: readonly ObjectInterfaceTemplateField[];
}

export function renderObjectInterfaceFile(options: ObjectInterfaceTemplateOptions): string {
  const { objectName, interfaceName, description, sourcePath, traits, generatedAt, fields } =
    options;

  const headerLines: string[] = [`Interface definitions for ${objectName}`];

  if (description && description.trim().length > 0) {
    headerLines.push(description.trim());
  }

  headerLines.push(
    '',
    'DO NOT EDIT - This file is auto-generated by the object type generator.'
  );
  
  if (sourcePath) {
    headerLines.push(`Source: ${sourcePath}`);
  }
  
  if (traits.length > 0) {
    headerLines.push(`Traits: ${traits.join(', ')}`);
  }
  
  if (generatedAt) {
    headerLines.push(`Generated at: ${generatedAt.toISOString()}`);
  }

  const filteredHeader = headerLines.filter(
    (line): line is string => line !== undefined && line !== null
  );

  const headerComment = renderJsDoc(filteredHeader);

  // Add StateTransition type definition if needed
  const needsStateTransition = fields.some(field => field.type.includes('StateTransition'));
  const stateTransitionType = needsStateTransition ? 
    `export interface StateTransition {
  readonly from_state: string;
  readonly to_state: string;
  readonly timestamp: string;
  readonly reason?: string;
  readonly actor_id?: string;
}

` : '';

  const interfaceLines: string[] = [];
  interfaceLines.push(`export interface ${interfaceName} {`);

  if (fields.length === 0) {
    interfaceLines.push('  // No schema fields were produced during composition.');
  } else {
    fields.forEach((field) => {
      const docBlock = renderJsDoc(field.jsDoc);
      const optionalFlag = field.optional ? '?' : '';
      const declaration = `${field.name}${optionalFlag}: ${field.type};`;

      if (docBlock) {
        interfaceLines.push(indent(docBlock.trimEnd(), 2));
      }
      interfaceLines.push(`  ${declaration}`);
      interfaceLines.push('');
    });

    if (interfaceLines[interfaceLines.length - 1] === '') {
      interfaceLines.pop();
    }
  }

  if (traits.includes('Authable')) {
    interfaceLines.push('');
    interfaceLines.push(...renderAuthableHelperMethods());
  }

  if (traits.includes('Communicable')) {
    interfaceLines.push('');
    interfaceLines.push(...renderCommunicableHelperMethods(inferCommunicableTarget(objectName)));
  }

  interfaceLines.push('}');

  return `${headerComment}${headerComment ? '\n' : ''}${stateTransitionType}${interfaceLines.join('\n')}\n`;
}

function renderJsDoc(lines: readonly string[]): string {
  const filtered = lines.filter((line) => line !== undefined && line !== null);
  if (filtered.length === 0) {
    return '';
  }

  const resolved = filtered.map((line) => line ?? '');
  const formatted = resolved
    .map((line) => (line.length > 0 ? ` * ${line}` : ' *'))
    .join('\n');

  return `/**\n${formatted}\n */`;
}

function indent(block: string, spaces: number): string {
  const prefix = ' '.repeat(spaces);
  return block
    .split('\n')
    .map((line) => (line.length > 0 ? `${prefix}${line}` : line))
    .join('\n');
}

function renderAuthableHelperMethods(): string[] {
  const lines: string[] = [];
  const helperDocs = [
    {
      doc: [
        'Return Authable roles scoped to the provided organization identifier.',
        '',
        'Source: Authable (trait helper)',
      ],
      signature: 'getRolesInOrg?(organizationId: string): AuthzRoleDocument[];',
    },
    {
      doc: [
        'Check whether the user has a permission (UUID or resource:action) in the specified organization.',
        '',
        'Source: Authable (trait helper)',
      ],
      signature: 'hasPermission?(organizationId: string, permission: string): boolean;',
    },
    {
      doc: [
        'Emit a normalized entitlement export for downstream IAM integrations.',
        '',
        'Source: Authable (trait helper)',
      ],
      signature:
        'exportEntitlements?(organizationId: string): { roles: AuthzRoleDocument[]; permissions: AuthzPermissionDocument[] };',
    },
  ];

  helperDocs.forEach((entry, index) => {
    const doc = renderJsDoc(entry.doc);
    if (doc) {
      lines.push(indent(doc.trimEnd(), 2));
    }
    lines.push(`  ${entry.signature}`);
    if (index < helperDocs.length - 1) {
      lines.push('');
    }
  });

  return lines;
}

type CommunicableTarget = 'user' | 'organization' | 'generic';

function inferCommunicableTarget(objectName: string): CommunicableTarget {
  const normalized = objectName.trim().toLowerCase();
  if (normalized.includes('organization') || normalized.includes('org')) {
    return 'organization';
  }
  if (normalized.includes('user')) {
    return 'user';
  }
  return 'generic';
}

function renderCommunicableHelperMethods(target: CommunicableTarget): string[] {
  const lines: string[] = [];
  const messageType = "import('@/schemas/communication/message.js').Message";
  const messageVariablesType = "import('@/schemas/communication/message.js').MessageVariables";
  const messageStateType = "import('@/schemas/communication/common.js').MessageState";
  const conversationType = "import('@/schemas/communication/conversation.js').Conversation";
  const channelType = "import('@/schemas/communication/channel.js').Channel";
  const templateType = "import('@/schemas/communication/template.js').Template";
  const deliveryPolicyType = "import('@/schemas/communication/delivery-policy.js').DeliveryPolicy";
  const deliveryResultType = "import('@/traits/communication/runtime-types.js').MessageDeliveryResult";
  const slaMetricsType = "import('@/traits/communication/sla-monitor.js').SLAMetrics";

  const helperDocs: { readonly doc: readonly string[]; readonly signature: string }[] = [];

  if (target !== 'organization') {
    helperDocs.push(
      {
        doc: [
          'Send a message to one or more recipients, applying Authable + Preferenceable bridges.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `sendMessage?(recipientIds: string[], template: ${templateType}, variables?: ${messageVariablesType}): ${deliveryResultType};`,
      },
      {
        doc: [
          'Return messages associated with this entity (sent or received).',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `getMessages?(filters?: { status?: ${messageStateType}; since?: string; until?: string; channelType?: string; conversationId?: string }): ${messageType}[];`,
      },
      {
        doc: [
          'Return threaded conversations anchored to this entity.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `getConversations?(): ${conversationType}[];`,
      },
      {
        doc: [
          'Return total unread messages routed to this entity.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: 'getUnreadCount?(): number;',
      },
      {
        doc: [
          'Mark all messages as read for this entity.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: 'markAllAsRead?(): void;',
      }
    );
  }

  if (target !== 'user') {
    helperDocs.push(
      {
        doc: [
          'Broadcast a message to recipients scoped to the organization.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `broadcastMessage?(recipientIds: string[], template: ${templateType}, variables?: ${messageVariablesType}): ${deliveryResultType};`,
      },
      {
        doc: [
          'Return registered channels for the organization.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `getChannels?(): ${channelType}[];`,
      },
      {
        doc: [
          'Return templates, optionally filtered by channel type.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `getTemplates?(channelType?: string): ${templateType}[];`,
      },
      {
        doc: [
          'Return delivery policies linked to the organization.',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `getDeliveryPolicies?(): ${deliveryPolicyType}[];`,
      },
      {
        doc: [
          'Return SLA metrics for the requested window (hours string or numeric).',
          '',
          'Source: Communicable (trait helper)',
        ],
        signature: `getSLAMetrics?(window: string | number): ${slaMetricsType};`,
      }
    );
  }

  helperDocs.forEach((entry, index) => {
    const doc = renderJsDoc(entry.doc);
    if (doc) {
      lines.push(indent(doc.trimEnd(), 2));
    }
    lines.push(`  ${entry.signature}`);
    if (index < helperDocs.length - 1) {
      lines.push('');
    }
  });

  return lines;
}
